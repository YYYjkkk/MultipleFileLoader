第六章 语法制导翻译与属性文法

重点：语法制导翻译的基本思想，语法制导定义，翻译模式，自顶向	   下翻译，自底向上翻译。

难点：属性的意义，对综合属性，继承属性，固有属性的理解，属性	   计算，怎么通过属性来表达翻译。

第6章 语法制导翻译与属性文法

6.1 语法制导翻译概述

6.2 语法制导定义

6.3 属性计算

6.4 翻译模式

6.5 本章小结

2024/10/14

2

6.1 语法制导翻译概述

为了提高编译程序的可移植性，一般将编译程序划分为前端和后端。

前端通常包括词法分析、语法分析、语义分析、中间代码生成、符号表的建立，以及与机器无关的中间代码优化等，它们的实现一般不依赖于具体的目标机器。

后端通常包括与机器有关的代码优化、目标代码的生成、相关的错误处理以及符号表的访问等。

图6.1 编译器前端的逻辑结构

2024/10/14

3

6.1 语法制导翻译概述

语义分析器的主要任务是检查各个语法结构的静态语义 ，称为静态语义分析或静态检查

类型检查：操作数和操作符的类型是否相容；

控制流检查：控制流转向的目标地址是否合法；

惟一性检查：对象是否被重复定义；

关联名检查：同一名字的多次特定出现是否一致。

将静态检查和中间代码生成结合到语法分析中进行的技术称为语法制导翻译 。

2024/10/14

4

6.1 语法制导翻译概述

语法制导翻译的基本思想

在进行语法分析的同时，完成相应的语义处理。也就是说，一旦语法分析器识别出一个语法结构就要立即对其进行翻译，翻译是根据语言的语义进行的，并通过调用事先为该语法结构编写的语义子程序来实现。

对文法中的每个产生式附加一个/多个语义动作(或语义子程序)，在语法分析的过程中，每当需要使用一个产生式进行推导或归约时，语法分析程序除执行相应的语法分析动作外，还要执行相应的语义动作(或调用相应的语义子程序)。

2024/10/14

5

6.1 语法制导翻译概述

语义子程序的功能

指明相应产生式中各个文法符号的具体含义，并规定了使用该产生式进行分析时所应采取的语义动作(如传送或处理语义信息、查填符号表、计算值、生成中间代码等)。

语义信息的获取和加工是和语法分析同时进行的，而且这些语义信息是通过文法符号来携带和传递的。 2024/10/14 6 6.1 语法制导翻译概述 一个文法符号X所携带的语义信息称为X的语义属性，简称为属性，它是根据翻译的需要设置的(对应分析树结点的数据结构)，主要用于描述语法结构的语义。 一个变量的属性有类型、层次、存储地址等 表达式的属性有类型、值等。 2024/10/14 7 6.1 语法制导翻译概述 属性值的计算和产生式相关联，随着语法分析的进行，执行属性值的计算，完成语义分析和翻译的任务。 E→E1 + E2		E.val:=E1.val+E2.val 语法结构具有规定的语义 问题：如何根据被识别出的语法成分进行语义处理？ 亦即怎样将属性值的计算及翻译工作同产生式相关联？ 2024/10/14 8 典型处理方法一 语法制导定义 通过将属性与文法符号关联、将语义规则与产生式关联来描述语言结构的翻译方案 对应每一个产生式编写一个语义子程序，当一个产生式获得匹配时，就调用相应的语义子程序来实现语义检查与翻译 E→E1 + T	{E.val:=E1.val+T.val} T→T1 * F	{T.val:=T1.val*F.val} F →digit	{F.val:=digit.lexval} 适宜在完成归约的时候进行 2024/10/14 9 典型处理方法二 语法制导翻译模式 通过将属性与文法符号关联，并将语义规则插入到产生式的右部来描述语言结构的翻译方案 在产生式的右部的适当位置，插入相应的语义动作，按照分析的进程，执行遇到的语义动作 D → T { L.inh := T.type } L T → int { T.type := integer } T → real { T.type := real } L → { L1.inh := L.inh }L1,id{addtype(id.entry,L.inh) } L → id{addtype(id.entry,L.inh)} 适宜在进行推导时完成 2024/10/14 10 6.2 语法制导定义 语法制导定义是附带有属性和语义规则的上下文无关文法 属性是与文法符号相关联的语义信息 语义规则是与产生式相关联的语义动作 语法制导定义是基于语言结构的语义要求设计的，类似于程序设计。 语法制导定义中的属性类似于程序中用到的数据结构，用于描述语义信息； 语义规则类似于计算，用于收集、传递和计算语义信息的。 属性通常被保存在分析树的相关节点中 2024/10/14 11 概念术语 综合属性：节点的属性值是通过分析树中该节点或其子节点的属性值计算出来的 继承属性：节点的属性值是由该节点、该节点的兄弟节点或父节点的属性值计算出来的 固有属性：通过词法分析直接得到的属性

依赖图：描述属性之间依赖关系的图，根据语义规则来构造 注释分析树：节点带有属性值的分析树 2024/10/14 12 语法制导定义的形式 在一个语法制导定义中，A→P都有与之相关联的一套语义规则，规则形式为 b：= f（c1，c2，…，ck）， f是一个函数，而且 1．b是A的一个综合属性并且c1，c2，…，ck是中的 符号的属性， 或者 2．b是中某个符号的一个继承属性并且c1，c2，…， ck是A或中的任何文法符号的属性。 这两种情况下，都说属性b依赖于属性c1，c2，…，ck 2024/10/14 13 例6.1 台式计算器的语法制导定义 产生式                      语义规则 LEn                      print(Eval)(可看作是L的虚属性) E E1+T                 Eval := E1val+Tval E T                       Eval := Tval T T1*F                 Tval := T1val*Fval T F                       Tval := Fval F (E)                     Fval := Eval F digit                   Fval := digitlexval 2024/10/14 14 S-属性定义 只含综合属性的语法制导定义称为S-属性定义

对于S

属性定义，通常使用自底向上的分析方法，在建立每一个结点处使用语义规则来计算综合属性值，即在用某个产生式进行归约后，就执行该产生式的S

属性定义计算属性的值，从叶结点到根结点进行计算。

没有副作用的语法制导定义有时又称为属性文法，属性文法的语义规则单纯根据常数和其它属性的值来定义某个属性的值

2024/10/14

15

继承属性

当分析树的结构同源代码的抽象语法不“匹配”时，继承属性将非常有用。下面的例子可以说明怎样用继承属性来解决这种不匹配问题，产生这种不匹配的原因是因为文法通常是为语法分析而不是为翻译设计的。

例6.2 考虑如何在自顶向下的分析过程中计算3*5和4*8*9这样的表达式项 消除左递归之后的算数表达式文法的一个子集： T→FT '   T '→*FT1'   T '→ε   F→digit 推导出4*8*9 2024/10/14 16 表6.3 为适于自顶向下分析的文法设计的语法制导定义 对输入4*8*9的自顶向下分析是从产生式T→FT1'开始的。F生成数字4，但*是由T '生成的，所以运算符*与其左运算数出现在分析树的不同子树中。为了将左运算数传递到运算符*中，需要将属性值从分析树当前节点的较左子树传递到较右的子树，所以需要引入一个继承属性。 产生式 语义规则 T→FT ' T '.inh := F.val T.val:= T '.syn T '→*FT1' T1'.inh := T '.inh×F.val T '.syn := T1'.syn T '→ε T '.syn := T '.inh F→digit F.val:=digit.lexval

属性值在兄弟节点间传递

2024/10/14

17

4

8

9的注释分析树

产生式 语义规则 T-FT T'.inh := F.val T.val:= T'.syn T'→*FT' T'inh := T'.inh X F.val T'.syn := T,'syn T'→8 T'.syn := T'inh Fdigit F.val:=digit.lexval

2024/10/14 18 表6.3中语法制导定义对应的翻译模式 由于属性值的计算必须在它所依赖的全部属性都被计算出来之后才能进行，所以此时属性val的值无法在用整个产生式归约(或推导)时一次完成，而是需要被穿插在产生式右部的某些位置上进行。 例如，不管是用T→FT '归约还是推导，都必须在识别出F之后才能将F的值传递给T '，也就是说，语义动作必须插入到产生式右部的某个位置上，这正好是翻译模式对翻译方案的描述方式 T→F{T '.inh := F.val}T '{T.val:= T '.syn} T '→*F{T1'.inh := T '.inh×F.val}T1'{T '.syn := T1'.syn} T '→ε{T '.syn := T '.inh} F→digit{F.val:=digit.lexval} 计算顺序的解释 2024/10/14 19 S-属性定义 定义6.1  只含综合属性的语法制导定义称为S-属性定义，又称为S-属性文法。 如果某个语法制导定义是S-属性定义，则可以按照自下而上的顺序来计算分析树中节点的属性。 一种简单的属性计算方法是对分析树进行后根遍历，并在最后一次遍历节点N时计算与节点N相关联的属性。 postorder(N) { for N的每个子节点M(从左到右) postorder(M); 计算与节点N相关联的属性; } 2024/10/14 20 L-属性定义 L：left的首字母。属性可以自下而上，自左向右传播 定义6.2 一个语法制导定义被称为L-属性定义，当且仅当它的每个属性或者是综合属性，或者是满足如下条件的继承属性：设有产生式A→X1X2…Xn，其右部符号Xi(1≤i≤n)的继承属性只依赖于下列属性： ⑴ A的继承属性； ⑵ 产生式中Xi左边的符号X1、X2、…、Xi-1的综合属性或继承属性； ⑶ Xi本身的综合属性或继承属性，但前提是Xi的属性不能在依赖图中形成回路。 L-属性定义又称为L-属性文法。 A的综合属性可以吗? 2024/10/14 21 表6.3 L-属性定义示例 产生式 语义规则 T→FT ' T '.inh := F.val T.val:= T '.syn T '→*FT1' T1'.inh := T '.inh×F.val T '.syn := T1'.syn T '→ε T '.syn := T '.inh F→digit F.val:=digit.lexval 2024/10/14 22 例6.7 不是L-属性定义的语法制导定义 产生式 语义规则 A→BC A.syn := B.b B.inh:=f(C.c, A.syn) 语义规则B.inh:=f(C.c, A.syn)定义了一个继承属性，所以整个语法制导定义就不是S-属性定义了。虽然这条语义规则是合法的属性定义规则，但不满足L-属性定义的要求。 这是因为：属性B.inh的定义中用到了属性C.c，而C在产生式的右部处在B的右边。虽然在L-属性定义中可以使用兄弟节点的属性来定义某个属性，但这些兄弟节点必须是左兄弟节点才行。因此，该语法制导定义也不是L-属性定义。 2024/10/14 23 L-属性定义中的属性计算 visit(N) { for N的每个子节点M(从左到右) { 计算节点M的继承属性; visit (M); } 计算节点N的综合属性; }; 2024/10/14 24 6.3.5 属性计算示例—抽象语法树的构造 抽象语法树是表示程序层次结构的树，它把分析树中对语义无关紧要的成分去掉，是分析树的抽象形式 ，也称作语法结构树，或结构树。

语法树是常用的一种中间表示形式。 把语法分析和翻译分开。语法分析过程中完成翻译有许多优点，但也有一些不足： 1.适于语法分析的文法可能不完全反映语言成分的自然层次结构； 2.由于语法分析方法的限制，对分析树结点的访问顺序和翻译需要的访问顺序不一致。 2024/10/14 25 语法树 产生式S→if B then S1 else S2的语法树 if-then-else ／  |   ＼ B   S1    S2 赋值语句的语法树 assignment

variable         expression 在语法树中，运算符号和关键字都不在叶结点，而是在内部结点中出现。

2024/10/14 26 构造表达式的语法树 构造表达式的语法树使用的函数 1. mknode(op, left, right) 建立一个标记为op的运算符结点，两个域left和right分别是指向左右运算对象的指针。 2．mkleaf(id, entry) 建立一个标记为id的标识符结点，其域entry是指向该标识符在符号表中相应表项的指针。 3. mkleaf(num, val) 建立一个标记为num的数结点，其域val用于保存该数的值。 2024/10/14 27 构造表达式语法树的语法制导定义 产生式 语义规则 ⑴ T → T1 * F T.node := mknode('*', T1.node, F.node) ⑵ T → T1 / F T.node := mknode('/', T1.node, F.node) ⑶ T → F T.node := F.node ⑷ F → (E) F.node:= E.node ⑸ F → id F.node := mkleaf(id, id.entry) ⑹ F → num F.node := mkleaf(num, num.val) 2024/10/14 28 图6.5 3*x/y的语法树的构造 p1:=mkleaf(num,3)； p2:=mkleaf(id, entry-x)； p3:=mknode('*', p1, p2)； p4:=mkleaf(id, entry-y)； p5:=mknode('/', p3, p4)； 图6.5的语法树是自底向上构造的，对于那些为便于进行自顶向下分析而设计的文法来说，使用同样的步骤照样可以建立图6.5中的抽象语法树。当然，分析树的结构可能大不相同，而且可能需要引入继承属性来传递语义信息。 2024/10/14 29 在自顶向下分析过程中构造语法树 产生式 语义规则 ⑴ T →FT ' T.node := T '.syn T '.inh := F.node ⑵ T ' → *FT1' T1'.inh := mknode('*', T '.inh, F.node) T '.syn:= T1'.syn ⑶ T ' → /FT1' T1'.inh := mknode('/', T '.inh, F.node) T '.syn:= T1'.syn ⑷ T ' → ε T '.syn := T '.inh ⑸ F → (E) F.node := E.node ⑹ F → id F.node := mkleaf(id, id.entry) ⑺ F → num F.node := mkleaf(num, num.val) L-属性定义 2024/10/14 30 根据表6.6的语法制导定义构造的语法树

产生式 语义规则 (1) T →→FT' T'.syn T.node := T'inh := F.node (2) T'→*FT, T'inh := mknode('*', T'inh, F.node) T'.syn:= T'syn (3) T' → /FT, T,'inh := mknode('/, T'inh, F.node) T'.syn:= T,'.syn (4) T' →& T'.syn := T'inh (5) F →(E) F.node := E.node (6) F → id F.node := mkleaf(id, id.entry) (7)F→ F.node := mkleaf(num, num.val) num2024/10/14 31 回顾 语法制导翻译 将静态检查和中间代码生成结合到语法分析中进行的技术 一旦语法分析器识别出一个语法结构就要立即对其进行翻译，通过语义子程序实现 语法制导定义 对应每一个产生式编写一个语义子程序，产生式获得匹配时，就调用相应的语义子程序来实现语义检查与翻译 E→E1 + T	{E.val:=E1.val+T.val} T→T1 * F	{T.val:=T1.val*F.val} F →digit	{F.val:=digit.lexval} 2024/10/14 32 回顾 语法制导翻译 将静态检查和中间代码生成结合到语法分析中进行的技术 一旦语法分析器识别出一个语法结构就要立即对其进行翻译，通过语义子程序实现 1、语法制导定义 2、语法制导翻译方案 过将属性与文法符号关联、将语义规则与产生式关联来描述语言结构的翻译方案 D → T { L.inh := T.type } L T → int { T.type := integer } T → real { T.type := real } L → { L1.inh := L.inh }L1,id{addtype(id.entry,L.inh) } L → id{addtype(id.entry,L.inh)} 2024/10/14 33 回顾 语法制导翻译 将静态检查和中间代码生成结合到语法分析中进行的技术 一旦语法分析器识别出一个语法结构就要立即对其进行翻译，通过语义子程序实现 1、语法制导定义 2、语法制导翻译方案

综合属性

计算 语义规则 属性 语义信息 固有属性 算法 继承属性 2024/10/14 34 数据结构 回顾 语法制导翻译 将静态检查和中间代码生成结合到语法分析中进行的技术 一旦语法分析器识别出一个语法结构就要立即对其进行翻译，通过语义子程序实现 1、语法制导定义 2、语法制导翻译方案 T→F{T '.inh := F.val}T '{T.val:= T '.syn} T '→*F{T1'.inh := T '.inh×F.val}T1'{T '.syn := T1'.syn} T '→ε{T '.syn := T '.inh} F→digit{F.val:=digit.lexval} 2024/10/14 35 回顾 语法制导翻译 将静态检查和中间代码生成结合到语法分析中进行的技术 一旦语法分析器识别出一个语法结构就要立即对其进行翻译，通过语义子程序实现 1、语法制导定义 2、语法制导翻译方案 S-属性定义 只含综合属性的语法制导定义 口定义6.2一个语法制导定义被称为L-属性定义， 当且仅当它 的每个属性或者是综合属性， 或者是满足如下条件的继承属 性：设有产生式A→X,X2...Xn， 其右部符号X(1≤n)的继承属 性只依赖于下列属性： (1)A的继承属性; (2)产生式中X,左边的符号X、X2、 ：·.、X的综合属性或继承属性； (3)X本身的综合属性或继承属性，但前提是X的属性不能在依赖图中 形成回路。 L-属性定义 2024/10/14 36 6.4  翻译模式 定义 翻译模式是语法制导定义的一种便于实现的书写形式。其中属性与文法符号相关联，语义规则或语义动作用花括号｛ ｝括起来，并可被插入到产生式右部的任何合适的位置上。 这是一种语法分析和语义动作交错的表示法，它表达在按深度优先遍历分析树的过程中何时执行语义动作。 翻译模式给出了使用语义规则进行计算的顺序。可看成是分析过程中翻译的注释。 2024/10/14 37 例6.10  一个简单的翻译模式 将中缀表达式翻译成后缀表达式： E→TR R→addop T {print(addop.lexeme)}R1|ε T→num{print(num.val)} 把语义动作看成终结符号，输入3+4-5,其分析树如图6.8，当按深度优先遍历它，执行遍历中访问的语义动作，将输出 3 4 + 5 - 它是输入表达式3+4-5的后缀式。 2024/10/14 38 图6.8  3+4-5的带语义动作的分析树 E→TR R—addop {print(addop.lexeme)}R,/& T T—→num (num.val)} print2024/10/14 39 翻译模式的设计——根据语法制导定义 前提——语法制导定义是L-属性定义 保证语义动作不会引用还没计算出来的属性值

1. 只需要综合属性的情况 为每一个语义规则建立一个包含赋值的动作，并把该动作放在相应的产生式右部的末尾。 例如：TT1*F      Tval:=T1val*Fval 转换成： TT1*F{Tval:=T1val*Fval} 2024/10/14 40 翻译模式的设计——根据语法制导定义 2. 既有综合属性又有继承属性 产生式右边的符号的继承属性必须在这个符号以前的动作中计算出来。 一个动作不能引用这个动作右边符号的综合属性。 产生式左边非终结符号的综合属性只有在它所引用的所有属性都计算出来以后才能计算。计算这种属性的动作通常可放在产生式右端的末尾。 2024/10/14 41

下面的翻译模式不满足要求： SA1A2 {A1in:=1;     A2in:=2} A a { print(Ain)  }   /*A.in尚无定义*/ 例6.11  从L-属性制导定义建立一个满足上面要求的翻译模式。 使用文法产生的语言是数学排版语言EQN E sub 1val 编排结果

2024/10/14

42

B表示盒子

⑴ B→B1B2代表两个相邻盒子的并列，且B1位于B2的左边。

⑵ B→B1 sub B2代表盒子B1后随下标盒子B2，下标盒子 B2以较小的字体和较低的位置出现。

⑶ B→(B1)代表一个由括号括起来的盒子B1，主要是为了对多个盒子或下标进行分组。在EQN中，使用花括号进行分组，此处使用圆括号是为了避免跟语义动作外面的花括号产生冲突。

⑷ B→text代表文本字符串，即任意字符组成的串。

该文法是二义性的文法，将“并列”和“下标”看成是左结合的，并令“下标”的优先级高于“并列”的话，则可以对该文法所描述的语言进行自底向上的语法分析。

2024/10/14

43

属性设置

⑴ point size用于表示盒子中文本的尺寸(以点来计算，也就是字号)。如果标准盒子的尺寸为p，则下标盒子的尺寸为0.7×p。属性B.ps表示盒子B的尺寸，该属性是继承属性。

⑵ 每个盒子都有一个基线(baseline)，用来表示每个文本底部的垂直位置。

⑶ height用来表示从盒子的顶部到基线的距离。属性B.ht表示盒子B的高度height，该属性是综合属性。

⑷ depth用来表示从基线到盒子底部的距离。用属性B.dp表示盒子B的深度depth，该属性也是综合属性。 2024/10/14 44 表6.7  对盒子进行排版的语法制导定义 产生式 语义规则 ⑴S →B B.ps:=10 S.ht := B.ht S.dp:= B.dp ⑵B → B1B2 B1.ps := B.ps B2.ps := B.ps B.ht := max(B1.ht, B2.ht) B.dp := max(B1.dp, B2.dp) ⑶B→B1 sub B2 B1.ps:=B.ps B2.ps:=0.7×B.ps B.ht:=max(B1.ht, B2.ht-0.25×B.ps) B.dp:=max(B1.dp, B2.dp+0.25×B.ps) ⑷B →(B1) B1.ps:=B.ps B.ht:=B1.ht B.dp:=B1.dp ⑸B →text B.ht:=getheight(B.ps,text.lexval) B.dp:=getdepth(B.ps,text.lexval) 2024/10/14 45 从表6.7构造的翻译模式 S→{B.ps:=10}B {S.ht := B.ht;S.dp:= B.dp} B→{B1.ps:=B.ps}B1{B2 .ps:=B.ps} B2{B.ht:=max(B1.ht,B2.ht)} B→{B1.ps:=B.ps}B1sub{B2.ps:=0.7×B.ps} B2{B.ht:=max(B1.ht,B2.ht-0.25×B.ps); B.dp:=max(B1.dp,B2.dp+0.25×B.ps);} B→({B1.ps:=B.ps}B1){B.ht:=B1.ht; B.dp:=B1.dp;} B→text{B.ht:=getheight(B.ps,text.lexval); B.dp:=getdepth(B.ps,text.lexval)} 2024/10/14 46 从表6.6构造的翻译模式 T → F {T '.inh := F.node}T '{T.node := T '.syn} T ' → *F {T1'.inh := mknode('*', T '.inh,F.node)} T1'{T '.syn := T1'.syn} T ' → /F {T1'.inh := mknode('/', T '.inh,F.node)} T1'{T '.syn := T1'.syn} T ' →ε {T '.syn := T '.inh} F → (E ){F.node := E.node} F→ id {F.node := mkleaf(id, id.entry)} F→ num {F.node := mkleaf(num, num.val)} 2024/10/14 47 6.4.2 S-属性定义的自底向上计算 在分析栈中使用一个附加的域来存放综合属性值。下图为一个带有综合属性值域的分析栈： stack val ... ...

X

X.x

Y

Y.y

top

Z

Z.z

... ... 文法符号 值 2024/10/14 48 A       b:=f(c1,c2,…,ck) b是A的综合属性，ci (1 ik)是中符号的属性。综合属性的值是在自底向上的分析过程中，每次归约之前进行计算的。 AXYZ    Aa:=f(Xx,Yy,Zz) Aa

Xx        Yy       Zz 2024/10/14 49 stack val ... ... A A.a

top

top

stack

val

...

...

X

X.x

Y

Y.y

Z

Z.z

实现时，将定义式 A.a:=f(X.x, Y.y, Z.z) (抽象)变成: stack[ntop].val:=f(stack[top-2].val, stack[top-1].val, stack[top].val) 具体可执行的代码 在执行代码段之前执行： ntop:=top-r+1   ——r是句柄的长度 执行代码段后执行：  top:=ntop; 2024/10/14 50 例6.14 用LR分析器实现台式计算器——与表6.2对比 L→En{print(stack[top-1].val);top:=top-1;} E→E1+T{stack[top-2].val:= stack[top-2].val + stack[top].val; top:=top-2;} E→T T→T1*F{stack[top-2].val:= stack[top-2].val × stack[top].val; top:=top-2;} T→F F→(E){ stack[top-2].val:= stack[top-1].val;top:=top-2;} F→digit 表6. 2 一个简单台式计算器的语法制导定义 语义规则 产生式 print( E. val) L-→En E-→E, + T E. val: = E,. val + T. val E→T E. val: = T. val T→T, * F T. val: = T. val x F. val T-→F T. val : = F. val F-→(E) F. val: =E. val F-→digit F. val : = digit. lexval 2024/10/14 51 表6.8 翻译输入6+7*8n上的移动序列 输入          stack     val        产生式 L→En{print(stack[top-1].val);top:=top-1;} E—→E,+T{stack[top-2].val:= stack[top-2].val + stack[top].val; top:=top-2;} E—T T→T,*F{stack[top-2].val:= stack[top-2].val X stack[top].val; top:=top-2;} T—F F→(E){ stack[top-2].val:= stack[top-1].val;top:=top-2;} F→digit6+7*8n      -           - +7*8n      6           6 +7*8n      F           6          Fdigit +7*8n      T           6          TF stack X Y Z 状态/文法符号 X.x Y.y Z.z 综合属性 val top+7*8n      E           6           ET 7*8n      E+         6- *8n       E+7      6-7 2024/10/14 52 表6.8 翻译输入6+7*8n上的移动序列 *8n      E+F          6-7        F digit L→En{print(stack[top-1].val);top:=top-1;} E—→E,+T{stack[top-2].val:= stack[top-2].val + stack[top].val; top:=top-2;} E—T T→T,*F{stack[top-2].val:= stack[top-2].val X stack[top].val; top:=top-2;} T—F F→(E){ stack[top-2].val:= stack[top-1].val;top:=top-2;} F→digit*8n      E+T          6-7        T F 8n      E+T*        6-7-

n      E+T*8      6-7-8 n      E+T*F      6-7-8     F  digit n      E+T           6-56     TT*F F 8 *

T

7

+

E

6

stack

value

n     E                62        E E+T T 56 +

E 6 stack value En              62- L                62         L En 2024/10/14 53 S-属性定义小结 采用自底向上分析，例如LR分析，首先给出S-属性定义，然后，把S-属性定义变成可执行的代码段，这就构成了翻译程序。 象一座建筑，语法分析是构架，归约处有一个“挂钩”，语义分析和翻译的代码段（语义子程序）就挂在这个钩子上。 这样，随着语法分析的进行，归约前调用相应的语义子程序,完成翻译的任务。 2024/10/14 54 6.4.3 L-属性定义的自顶向下翻译 用翻译模式构造自顶向下的翻译。 1. 从翻译模式中消除左递归 对于一个翻译模式，若采用自顶向下分析，必须消除左递归和提取左公因子，在改写基础文法时考虑属性值的计算。 对于自顶向下语法分析，将语义动作看作终结符号，当其处在栈顶时将被弹出执行，而且不考虑继承属性的处理（很简单）。 2024/10/14 55 只有简单语义动作时的左递归消除 例6.15 考虑如下将中缀表达式翻译为后缀表达式的翻译模式中的两个产生式： E → E1+T {print(‘+’);} E → T 消除左递归 E → TR R → +T {print(‘+’);} R R → ε A→Aα βA→→βR R→αR

2024/10/14

56

S

属性定义的左递归消除

设有如下左递归翻译模式：

A→A1Y｛A.a:=g(A1.a,Y.y)}

A→X ｛A.a:=f(X.x)}

假设每个非终结符都有一个综合属性，用相应的小写字母表示，g和f是任意函数。

消除左递归后，文法转换成 A→X R R→Y R|ε 2024/10/14 57 S-属性定义的左递归消除 引入继承属性R.i来收集应用函数g的计算结果。其初始值为A.a:=f(X.x） A→A1Y {A.a:=g(A1.a,Y.y)} A→X {A.a:=f(X.x)} 再考虑语义动作，翻译模式变为： A→X ｛Ri:=f(Xx)} R ｛Aa:=Rs} R→Y  ｛R1i:=g(Ri,Yy)} R1 ｛Rs:=R1s} R→ε  ｛Rs:=Ri} 经过转换的翻译模式使用R的继承属性i和综合属性s。 引入综合属性R.s在R结束生成Y时复制R.i的值。 2024/10/14 58 输入：XY1Y2 Aa=g(g(f(Xx),Y1y),Y2y)

Aa=g(f(Xx),Y1y)

Y2

Aa=f(Xx)

Y1

{A.a:=g(A

,.a,Y.y)}

A—→A,

Y

{A.a:=f(X.x)}

A→X

(a)

X

2024/10/14

59

A

X

Ri=f(Xx)

Y1

Ri=g(f(Xx),Y1y)

Y2

A→X {Ri:=f(Xx)}R{Aa:=Rs}

R→Y {R1i:=g(Ri,Yy)}R1{Rs:=R1s}

R→ε {Rs:=Ri}

Ri=g(g(f(Xx),Y1y),Y2y)

ε

2024/10/14

60

2. L

属性定义的递归下降翻译法

L

属性定义的递归下降翻译器的构造：

1．对每个非终结符A构造一个函数A，将非终结符A的各个继承属性当作函数A的形式参数，而将非终结符A的综合属性当作函数A的返回值，为了便于讨论，假设每个非终结符只具有一个综合属性。

2．在函数A的过程体中，不仅要进行语法分析，而且要处理相应的语义属性。函数A的代码首先根据当前输入确定用哪个产生式展开A，然后按照3中所给的方法对各产生式进行编码。

2024/10/14

61

2. L

属性定义的递归下降翻译法

3．与每个产生式对应的程序代码的工作过程为：按照从左到右的次序，依次对产生式右部的记号、非终结符和语义动作执行如下的动作：

1) 对带有综合属性x的符号X，将x的值保存在X.x中，并生成一个函数调用来匹配X，然后继续读入下一个输入符号；

2) 对非终结符B，生成一个右部带有函数调用的赋值语句c:=B(b1,b2,…,bk)，其中，b1,b2,…,bk是代表B的继承属性的变量，c是代表B的综合属性的变量；

3) 对于语义动作，将其代码复制到语法分析器中，并将对属性的引用改为对相应变量的引用。

2024/10/14

62

例 6.16

function T:↑syntax_tree_node; function T '(inh: ↑syntax_tree_node):↑syntax_tree_node; function F:↑syntax_tree_node; function T:↑syntax_tree_node; var node, syn: ↑syntax_tree_node; begin node := F; syn := T '(node); return syn end; 2024/10/14 63 function T '(inh: ↑syntax_tree_node):↑syntax_tree_node; var node,inh1,syn1: ↑syntax_tree_node; oplexeme:char; begin	if lookahead = ‘*’ then begin /* 匹配产生式T ' → *FT ' */ oplexeme := lexval; match(‘*’);   node := F; inh1:=mknode(‘*’, inh, node); syn1 := T '(inh1);   syn := syn1 end else if lookahead = ‘/’ then begin /* 匹配产生式T ' → /FT ' */ oplexeme := lexval; match(‘/’);    node := F; inh1:=mknode(‘/’, inh, node); syn1 := T '(inh1);    syn := syn1 end    else syn := inh;    return syn   end; 2024/10/14 64 function F:↑syntax_tree_node; var node: ↑syntax_tree_node; begin    if lookahead = ‘(’ then begin /* 匹配产生式F → (E) */ match(‘(‘);    node := E; match(‘)’) end else if lookahead = id then begin /* 匹配产生式F → id */ match(id);    node := mkleaf(id, id.entry)    end else if lookahead = num then begin /* 匹配产生式F → num */ match(num);    node := mkleaf(num, num.val) end    return node end; 2024/10/14 65 3.L-属性定义的LL(1)翻译法 预先在源文法中的相应位置上嵌入语义动作符号(每个对应一个语义子程序)，用于提示语法分析程序，当分析到达这些位置时应调用相应的语义子程序。 带有语义动作符号的文法又叫翻译文法。 2024/10/14 66 3.L-属性定义的LL(1)翻译法 与递归子程序法的区别与联系 都是在扫描过程中进行产生式的推导，同时在适当的地方加入语义动作。 递归子程序法将语义动融入分析程序；LL(1)分析法则由语义子程序完成相应的翻译。 递归子程序法隐式地使用语义栈； LL(1)分析法则用显式的语义栈（程序自身控制对栈的操作）。注：语义与语法栈不同步。 2024/10/14 67 例6.17 对于图6.14的翻译模式，设置两个栈，一个是分析栈，一个是语义栈。 ⑴ T→F{e1}T '{e2} ⑵ T '→*F{e3}T1'{e4} ⑶ T '→/F{e5}T1'{e4} ⑷ T '→ε{e6} ⑸ F→(E){e7} ⑹ F→id{e8} ⑺ F→num{e9} ⑴ T→F{e1}T '{e2} ⑵ T '→/F{e3}T1'{e4} ⑶ T '→*F{e5}T1'{e4} ⑷ T '→ε{e6} ⑸ F→(E){e7} ⑹ F→id{e8} ⑺ F→num{e9}

e1

e9表示语义动作

2024/10/14

68

例6.17 对输入串3

x/y的翻译

3

x/y#

输入串

语法分析动作和语义操作

1. 初始化

T

#

语义栈

语法栈

2024/10/14

69

例6.17 对输入串3

x/y的翻译

3

x/y#

输入串

(1) T→F{e1}T'{e2}

(2) T'→/F{e3}T'{e4}

(3) T'→→

F{e5}T'{e4}

(4) T'→ε{e6}

(5) F→(E){e7}

(6) F→id{e8}

(7) F→→num

{e9}语法分析动作和语义操作

F

{e1}

2. 选产生式①的右部进栈

T '

{e2}

#

语义栈

语法栈

2024/10/14

70

例6.17 对输入串3

x/y的翻译

3

x/y#

输入串

(1) T→F{e1}T'{e2}

(2) T'→/F{e3}T'{e4}

(3) T'→→

F{e5}T'{e4}

(4) T'→ε{e6}

(5) F→(E){e7}

(6) F→id{e8}

(7) F→→num

{e9}语法分析动作和语义操作

{e9}

{e1}

3.选择产生式⑺,num3不进栈，调用{e9}，调用{e9}后，叶结点F.node被压入语义栈

T '

F.node

{e2}

#

语义栈

语法栈

2024/10/14

71

例6.17 对输入串3

x/y的翻译

3

x/y#

输入串

(1) T→F{e1}T'{e2}

(2) T'→/F{e3}T'{e4}

(3) T'→→

F{e5}T'{e4}

(4) T'→ε{e6}

(5) F→(E){e7}

(6) F→id{e8}

(7) F→→num

{e9}语法分析动作和语义操作

{e1}

4.执行动作{e1}，F.node出栈，

T '.inh被压入栈

T '

T '.inh

{e2}

#

语义栈

语法栈

2024/10/14

72

例6.17 对输入串3

x/y的翻译

3

x/y#

输入串

(1) T→F{e1}T'{e2}

(2) T'→/F{e3}T'{e4}

(3) T'→→

F{e5}T'{e4}

(4) T'→ε{e6}

(5) F→(E){e7}

(6) F→id{e8}

(7) F→→num

{e9}F

语法分析动作和语义操作

{e5}

T '

5.选择产生式⑶,

不进栈

{e4}

{e2}

T '.inh

#

语义栈

语法栈

2024/10/14

73

例6.17 对输入串3

x/y的翻译

3

x/y#

输入串

(1) T→F{e1}T'{e2}

(2) T'→/F{e3}T'{e4}

(3) T'→→

F{e5}T'{e4}

(4) T'→ε{e6}

(5) F→(E){e7}

(6) F→id{e8}

(7) F→→num

{e9}{e8}

语法分析动作和语义操作

{e5}

T '

6.选择产生式⑹,idx不进栈，调用{e8}，调用{e8}后，叶结点F.node被压入语义栈

{e4}

F.node

{e2}

T '.inh

#

语义栈

语法栈

2024/10/14

74

例6.17 对输入串3

x/y的翻译

3

x/y#

输入串

(1) T→F{e1}T'{e2}

(2) T'→/F{e3}T'{e4}

(3) T'→→

F{e5}T'{e4}

(4) T'→ε{e6}

(5) F→(E){e7}

(6) F→id{e8}

(7) F→→num

{e9}语法分析动作和语义操作

{e5}

T '

7.执行动作{e5}，F.node和T '.inh均被弹出栈，新的T '.inh被压入栈

{e4}

{e2}

T '.inh

#

语义栈

语法栈

2024/10/14

75

例6.17 对输入串3

x/y的翻译

3

x/y#

输入串

F

(1) T→F{e1}T'{e2}

(2) T'→/F{e3}T'{e4}

(3) T'→→

F{e5}T'{e4}

(4) T'→ε{e6}

(5) F→(E){e7}

(6) F→id{e8}

(7) F→→num

{e9}{e3}

语法分析动作和语义操作

T '

{e4}

8.选择产生式⑵, /不进栈

{e4}

{e2}

T '.inh

#

语义栈

语法栈

2024/10/14

76

例6.17 对输入串3

x/y的翻译

3

x/y#

输入串

{e8}

(1) T→F{e1}T'{e2}

(2) T'→/F{e3}T'{e4}

(3) T'→→

F{e5}T'{e4}

(4) T'→ε{e6}

(5) F→(E){e7}

(6) F→id{e8}

(7) F→→num

{e9}{e3}

语法分析动作和语义操作

T '

{e4}

9.选择产生式⑹,idy不进栈，调用{e8}，调用{e8}后，叶结点F.node被压入语义栈

{e4}

F.node

{e2}

T '.inh

#

语义栈

语法栈

2024/10/14

77

例6.17 对输入串3

x/y的翻译

3

x/y#

输入串

(1) T→F{e1}T'{e2}

(2) T'→/F{e3}T'{e4}

(3) T'→→

F{e5}T'{e4}

(4) T'→ε{e6}

(5) F→(E){e7}

(6) F→id{e8}

(7) F→→num

{e9}{e3}

语法分析动作和语义操作

T '

{e4}

10.执行动作{e3}，F.node和T '.inh均被弹出栈，新的T '.inh被压入栈

{e4}

{e2}

T '.inh

#

语义栈

语法栈

2024/10/14

78

例6.17 对输入串3

x/y的翻译

3

x/y#

输入串

(1) T→F{e1}T'{e2}

(2) T'→/F{e3}T'{e4}

(3) T'→→

F{e5}T'{e4}

(4) T'→ε{e6}

(5) F→(E){e7}

(6) F→id{e8}

(7) F→→num

{e9}语法分析动作和语义操作

{e6}

{e4}

11.选择产生式⑷，T '.inh被弹出栈，T '.syn被压入栈

{e4}

{e2}

T '.inh

#

语义栈

语法栈

2024/10/14

79

例6.17 对输入串3

x/y的翻译

3

x/y#

输入串

(1) T→F{e1}T'{e2}

(2) T'→/F{e3}T'{e4}

(3) T'→→

F{e5}T'{e4}

(4) T'→ε{e6}

(5) F→(E){e7}

(6) F→id{e8}

(7) F→→num

{e9}语法分析动作和语义操作

12.依次执行动作{e6},{e4},{e4},{e2}, 最终语义栈中只有T.node, 代表3

x/y的语法树的根结点

T.node

#

语义栈

语法栈

2024/10/14

80

6.4.4 L

属性定义的自底向上翻译

在自底向上分析的框架中实现L属性定义的方法

它能实现任何基于LL(1)文法的L属性定义。

也能实现许多（但不是所有的）基于LR(1) 文法的L属性定义。

2024/10/14

81

6.4.4 L

属性定义的自底向上翻译(续)

⑴ 首先像6.4.1所介绍的那样构造翻译模式，它将计算继承属性的动作嵌入在非终结符的前面，而将计算综合属性的动作放在产生式的末尾。

⑵ 在每个嵌入动作处引入一个标记性非终结符(marker nonterminals)。不同位置所对应的标记是不同的，每个标记性非终结符M都有一个形如M→ε的产生式。 2024/10/14 82 6.4.4 L-属性定义的自底向上翻译(续) ⑶ 如果标记性非终结符M取代了某个产生式A→α{a}β中的动作a，则按如下方式将a修改为a'，并将动作{a'}放在产生式M→ε的末尾。 ①为M设置继承属性来复制动作a所需要的A或α中符号的继承属性； ② 以与动作a相同的方式计算属性，只不过要将这些属性置为M的综合属性。 2024/10/14 83 6.4.4 L-属性定义的自底向上翻译(续) 与M→ε相关联的语义动作可能需要用到没出现在该产生式中的文法符号的属性。不过，由于要在LR分析栈中实现所有的语义动作，所以在分析栈中M下面的某个已知位置总能找到所需的属性。 例如，假设在某个LL(1)文法中有一个形如A→BC的产生式，B的继承属性B.inh是从A的继承属性A.inh按照公式B.inh := f(A.inh)来计算的，亦即翻译模式可能包含如下片断： A→{B.inh := f(A.inh);}BC 2024/10/14 84 6.4.4 L-属性定义的自底向上翻译(续) 根据上面的论述，为了在自底向上的分析过程中计算B.inh := f(A.inh)，需要引入一个标记性非终结符M，并为其设置一个继承属性M.inh用来复制A的继承属性，而且还要用M的综合属性M.syn代替B.inh，于是，该翻译模式片段将被修改为如下形式： A→MBC M→ε {M.inh := A.inh; M.syn := f(M.inh)}

inh

inh

A—→

B.

BC

:=f(A.i

}2024/10/14

85

6.4.4 L

属性定义的自底向上翻译(续)

注意，执行M的语义规则时，A.inh是不可用的，但实际上，实现时会把每个非终结符X的继承属性都放在堆栈中紧靠在X将被归约出来的位置之下。于是，当将ε归约为M时，A.inh恰好就在它的下面。随M保存在栈中的M.syn的值，也就是B.inh的值，亦将被放在紧靠在B将被归约出来的位置之下，需要的时候同样是可用的。

2024/10/14

86

6.4.4 L

属性定义的自底向上翻译(续)

给定一个L

属性定义，假设它的每个非终结符A都有一个继承属性A.inh，而且每个文法符号X都有一个综合属性X.syn。

如果X是终结符，则其综合属性值就是词法分析器所返回的词法值。

假设分析栈仍是stack，语义栈仍为val。如果stack[i]代表文法符号X，则stack[i].val将保存其综合属性X.syn。

为了在自底向上的分析过程计算继承属性，需要对每个产生式A→Xl…Xn引入n个标记性非终结符M1，…，Mn，并用A→M1Xl…MnXn代替该产生式。

2024/10/14

87

6.4.4 L

属性定义的自底向上翻译(续)

归约标记性非终结符Mj时，它出现在产生式A→M1X1…MnXn中，从而可以确定为计算继承属性Xj.inh所需要的那些属性的位置：A.inh在stack[top

2j+2].val中，X1.inh在stack[top

2j+3].val中，X1.syn在 stack[top

2j+4].val中，X2.inh在stack[top

2j+5].val中，依次类推。于是，就可以计算出Xj.inh，并将其存放在stack[top+1].val中，归约后它成为新的栈顶。

2024/10/14

88

6.4.4 L

属性定义的自底向上翻译(续)

归约非标记符号

譬如用产生式A→M1X1…MnXn进行归约。在这种情况下，只需要计算综合属性A.syn，因为A.inh已经被计算出来了，而且放在栈中A将要插入的位置之下。

很明显，进行归约时，计算A.syn所需要的其它属性也都在栈中的已知位置，即Xj(1≤j≤n)所在的位置。

2024/10/14

89

6.4.4 L

属性定义的自底向上翻译(续)

下面的化简可以减少标记性非终结符的个数，其中第2条还可以避免左递归文法中的分析冲突：

⑴ 如果Xj没有继承属性，则不需要使用标记Mj。当然，如果省略了Mj，属性在栈中的预期位置就会改变，但是分析器可以很容易地适应这种变化。

⑵ 如果X1.inh存在，但它是由复制规则X1.inh := A.inh计算的，此时可以省略M1。因为A.inh存放在栈中紧挨在X1下面的地方，所以该值也可同时作为X1.inh的值。 2024/10/14 90 6.4.4 L-属性定义的自底向上翻译(续) 例6.18  数学排版语言EQN S  	{B.ps := 10 } B	{S.ht := B.ht; S.dp := B.dp } B  	{B1.ps := B.ps } B1	{B2.ps := B.ps } B2	{B.ht := max(B1.ht, B2.ht ) } B  	{ B1.ps :=B.ps } B1 sub	{ B2.ps := 0.7B.ps } B2	{B.ht := disp (B1.ht, B2.ht ) B.dp := max (B1.dp, B2.dp)} B  text{B.ht := getheight(B.ps,text.lexval); B.dp:=getdepth(B.ps,text.lexval)} 保证在B的子树被归约时，B.ps的值出现在分析栈中的已知位置 归约B1之前，B.ps可以在栈中找到，所以B1.ps := B.ps 可以省略。但归约B2之前，无法确定其前有几个B1，因此，无法预测B.ps在栈中的位置。 2024/10/14 91 6.4.4 L-属性定义的自底向上翻译(续) 由于存在一个继承属性和两个综合属性，所以语义栈val需要被扩展为val1、val2和val3 val1用于保存继承属性ps的值 val2和val3分别用于保存综合属性ht和dp的值 假设分析栈仍为stack top和ntop分别是归约前和归约后栈顶的下标。 2024/10/14 92 6.4.4 L-属性定义的自底向上翻译(续) 产  生  式 语   义   规   则 S  LB B.ps := L.syn;  S.ht := B.ht ;  S.dp := B.dp L   L.syn := 10 B  B1 MB2 B1.ps := B.ps;  M.inh := B.ps; B2.ps := M.syn;B.ht := max(B1.ht, B2.ht ) M   M.syn := M.inh B  B1 sub NB2 B1.ps :=B.ps;  N.inh := B.ps; B2.ps := N.syn; B.ht := disp (B1.ht, B2.ht); B.dp:=max(B1.dp, B2.dp) N   N.syn := 0.7N.inh B  text B.ht := getheight(B.ps,text.lexval); B.dp:= getdepth(B.ps,text.lexval) 2024/10/14 93 6.4.4 L-属性定义的自底向上翻译(续) 产  生  式 代   码   段 S  LB stack[ntop].val2 := stack[top].val2 stack[ntop].val3 := stack[top].val3 L   stack[ntop].val1 := 10 B  B1 MB2 stack[ntop].val2 := max(stack[top-2].val2, stack[top].val2) stack[ntop].val3 := max(stack[top-2].val3, stack[top].val3) M   stack[ntop].val1 := stack[top-1].val1 B  B1 sub NB2 stack[ntop].val2:= max(stack[top-3].val2, stack[top].val2-0.25×stack[top-4].val1) stack[ntop].val3 := max(stack[top-3].val3, stack[top].val3+0.25×stack[top-4].val1) N   stack[ntop].val1 := 0.7×stack[top-2].val1 B  text stack[ntop].val2 := getheight(stack[top-1].val1,text.lexval) stack[ntop].val3 := getdepth(stack[top-1].val1,text.lexval) 2024/10/14 94 本章小结 语法分析中进行静态语义检查和中间代码生成的技术称为语法制导翻译技术。

为了通过将语义属性关联到文法符号、将语义规则关联到产生式，有效地将语法和语义关联起来，人们引入了语法制导定义。没有副作用的语法制导定义又称为属性文法。

2024/10/14

95

本章小结

为相应的语法成分设置表示语义的属性，属性的值是可以计算的，根据属性值计算的关联关系，将其分成综合属性和继承属性，根据属性文法中所含的属性将属性文法分成S

属性文法和L

属性文法。

如果不仅将语义属性关联到文法符号、将语义规则关联到产生式，而且还通过将语义动作嵌入到产生式的适当位置来表达该语义动作的执行时机，这就是翻译模式。翻译模式给语义分析的实现提供了更好的支持。

2024/10/14

96

本章小结

注释分析树和相应的依赖图是属性值的关联关系和计算顺序的表达形式，语义关系可以使用抽象语法树表示。

依据语法分析方法有自底向上的和自顶向下的，语法制导翻译既可以按照自底向上的策略进行，也可以按照自顶向下的策略进行。

2024/10/14

97
